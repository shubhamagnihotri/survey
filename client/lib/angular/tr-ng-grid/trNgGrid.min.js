//"use strict"; var TrNgGrid; !function (e) { function t(e, t, i, r) { var n = t.startSymbol(), l = t.endSymbol(); e.get(i) || ("{{" !== n && (r = r.replace(/\{\{/g, n + " ")), "}}" !== l && (r = r.replace(/\}\}/g, " " + l)), e.put(i, r)) } function i(i, r) { t(i, r, e.cellHeaderTemplateId, '<div class="' + e.headerCellCssClass + '" ng-switch="isCustomized">  <div ng-switch-when="true">    <div ng-transclude=""></div>  </div>  <div ng-switch-default>    <div class="' + e.columnTitleCssClass + '">      {{columnTitle |' + e.translateFilter + ":gridOptions.locale}}       <div " + e.columnSortDirectiveAttribute + '=""></div>    </div>    <div ' + e.columnFilterDirectiveAttribute + '=""></div>  </div></div>'), t(i, r, e.cellBodyTemplateId, '<div ng-attr-class="' + e.bodyCellCssClass + ' text-{{columnOptions.displayAlign}}" ng-switch="isCustomized">  <div ng-switch-when="true">    <div ng-transclude=""></div>  </div>  <div ng-switch-default>{{gridDisplayItem[columnOptions.displayFieldName]}}</div></div>'), t(i, r, e.columnFilterTemplateId, '<div ng-show="(gridOptions.enableFiltering&&columnOptions.enableFiltering!==false)||columnOptions.enableFiltering" class="' + e.columnFilterCssClass + '"> <div class="' + e.columnFilterInputWrapperCssClass + '">   <input class="form-control input-sm" type="text" ng-model="columnOptions.filter" ng-keypress="speedUpAsyncDataRetrieval($event)"></input> </div></div>'), t(i, r, e.columnSortTemplateId, "<div ng-attr-title=\"{{'Sort'|" + e.translateFilter + ':gridOptions.locale}}" ng-show="(gridOptions.enableSorting&&columnOptions.enableSorting!==false)||columnOptions.enableSorting" ng-click="toggleSorting(columnOptions.fieldName)" class="' + e.columnSortCssClass + '" >   <div ng-class="{\'' + e.columnSortActiveCssClass + "':gridOptions.orderBy==columnOptions.fieldName,'" + e.columnSortInactiveCssClass + "':gridOptions.orderBy!=columnOptions.fieldName,'" + e.columnSortNormalOrderCssClass + "':gridOptions.orderBy==columnOptions.fieldName&&!gridOptions.orderByReverse,'" + e.columnSortReverseOrderCssClass + "':gridOptions.orderBy==columnOptions.fieldName&&gridOptions.orderByReverse}\" >  </div></div>"), t(i, r, e.cellFooterTemplateId, '<div class="' + e.footerCssClass + '" ng-switch="isCustomized">  <div ng-switch-when="true">    <div ng-transclude=""></div>  </div>  <div ng-switch-default>    <span ' + e.globalFilterDirectiveAttribute + '=""></span>    <span ' + e.pagerDirectiveAttribute + '=""></span>  </div></div>'), t(i, r, e.footerGlobalFilterTemplateId, '<span ng-show="gridOptions.enableFiltering" class="pull-left form-group">  <input class="form-control" type="text" ng-model="gridOptions.filterBy" ng-keypress="speedUpAsyncDataRetrieval($event)" ng-attr-placeholder="{{\'Search\'|' + e.translateFilter + ':gridOptions.locale}}"></input></span>'), t(i, r, e.footerPagerTemplateId, '<span class="pull-right form-group"> <ul class="pagination">   <li ng-class="{disabled:!pageCanGoBack}" ng-if="extendedControlsActive">     <a href="" ng-click="pageCanGoBack&&navigateToPage(0)" ng-attr-title="{{\'First Page\'|' + e.translateFilter + ':gridOptions.locale}}">         <span>&laquo;</span>     </a>   </li>   <li ng-class="{disabled:!pageCanGoBack}" ng-if="extendedControlsActive">     <a href="" ng-click="pageCanGoBack&&navigateToPage(gridOptions.currentPage - 1)" ng-attr-title="{{\'Previous Page\'|' + e.translateFilter + ':gridOptions.locale}}">         <span>&lsaquo;</span>     </a>   </li>   <li ng-if="pageSelectionActive" ng-repeat="pageIndex in pageIndexes track by $index" ng-class="{disabled:pageIndex===null, active:pageIndex===gridOptions.currentPage}">      <span ng-if="pageIndex===null">...</span>      <a href="" ng-click="navigateToPage(pageIndex)" ng-if="pageIndex!==null" ng-attr-title="{{\'Page\'|' + e.translateFilter + ':gridOptions.locale}}">{{pageIndex+1}}</a>   </li>   <li ng-class="{disabled:!pageCanGoForward}" ng-if="extendedControlsActive">     <a href="" ng-click="pageCanGoForward&&navigateToPage(gridOptions.currentPage + 1)" ng-attr-title="{{\'Next Page\'|' + e.translateFilter + ':gridOptions.locale}}">         <span>&rsaquo;</span>     </a>   </li>   <li ng-class="{disabled:!pageCanGoForward}" ng-if="extendedControlsActive">     <a href="" ng-click="pageCanGoForward&&navigateToPage(lastPageIndex)" ng-attr-title="{{\'Last Page\'|' + e.translateFilter + ':gridOptions.locale}}">         <span>&raquo;</span>     </a>   </li>   <li class="disabled" style="white-space: nowrap;">     <span ng-hide="totalItemsCount">{{\'No items to display\'|' + e.translateFilter + ":gridOptions.locale}}</span>     <span ng-show=\"totalItemsCount\">       {{startItemIndex+1}} - {{endItemIndex+1}} {{'displayed'|" + e.translateFilter + ":gridOptions.locale}}       <span>, {{totalItemsCount}} {{'in total'|" + e.translateFilter + ":gridOptions.locale}}</span>     </span >    </li> </ul></span>") } !function (e) { e[e.None = 0] = "None", e[e.SingleRow = 1] = "SingleRow", e[e.MultiRow = 2] = "MultiRow", e[e.MultiRowWithKeyModifiers = 3] = "MultiRowWithKeyModifiers" }(e.SelectionMode || (e.SelectionMode = {})); var r = e.SelectionMode; e.defaultColumnOptionsTemplate = { cellWidth: null, cellHeight: null, displayAlign: null, displayFormat: null, displayName: null, filter: null, enableFiltering: null, enableSorting: null }, e.defaultColumnOptions = {}, e.translations = {}, e.debugMode = !1; var n = !1, l = "trNgGrid"; e.sortFilter = l + "SortFilter", e.dataPagingFilter = l + "DataPagingFilter", e.translateFilter = l + "TranslateFilter", e.translationDateFormat = l + "DateFormat", e.dataFormattingFilter = l + "DataFormatFilter"; var a = "trNgGridBody", s = "tr-ng-grid-body", o = "field-name", d = "data-field-name", g = "is-customized", c = "trNgGridFooterCell", u = "tr-ng-grid-footer-cell", p = "trNgGridFooterCellTemplate", m = "tr-ng-grid-footer-cell-template"; e.cellFooterTemplateId = p + ".html"; var f = "trNgGridGlobalFilter"; e.globalFilterDirectiveAttribute = "tr-ng-grid-global-filter", e.footerGlobalFilterTemplateId = f + ".html"; var h = "trNgGridPager"; e.pagerDirectiveAttribute = "tr-ng-grid-pager", e.footerPagerTemplateId = h + ".html"; var v = "trNgGridHeaderCell", I = "tr-ng-grid-header-cell", y = "trNgGridHeaderCellTemplate", O = "tr-ng-grid-header-cell-template"; e.cellHeaderTemplateId = y + ".html"; var C = "trNgGridBodyCell", F = "tr-ng-grid-body-cell", D = "trNgGridBodyCellTemplate", S = "tr-ng-grid-body-cell-template"; e.cellBodyTemplateId = D + ".html"; var b = "trNgGridColumnSort"; e.columnSortDirectiveAttribute = "tr-ng-grid-column-sort", e.columnSortTemplateId = b + ".html"; var w = "trNgGridColumnFilter"; e.columnFilterDirectiveAttribute = "tr-ng-grid-column-filter", e.columnFilterTemplateId = w + ".html"; var x = function (e, t) { t = t.toUpperCase(); for (var i = e.children(), r = 0; r < i.length; r++) { var n = i[r]; if (n.tagName == t) return angular.element(n) } return null }, T = function (e, t, i, r) { var n = [], l = t.slice(0); return angular.forEach(e, function (e) { for (var t = null, i = 0; !t && i < l.length; i++) t = l[i], t.fieldName === e.fieldName ? l.splice(i, 1) : t = null; t ? n.push(t) : n.push(e) }), (i || r) && angular.forEach(l, function (e) { (i && e.fieldName || r && !e.fieldName) && n.push(e) }), n }, P = function (e, t, i, r) { if (i) { var n = e.children(), l = angular.element(n[0]); if (1 !== n.length || !l.attr(r)) { e.empty(); var a = angular.element("<div></div>").attr(r, ""); e.append(a), angular.forEach(n, function (e) { a.append(angular.element(e)) }) } } else e.empty(), e.append(angular.element("<div></div>").attr(r, "")) }, $ = function () { function e(e, t) { this.parent = e, this.cellElement = t, this.fieldName = t.attr(o) || t.attr(d); var i = t.children(); this.isStandardColumn = 0 === i.length } return e }(), N = function () { function e(e, t, i, r, n) { this.sectionTagName = e, this.sectionDirectiveAttribute = t, this.rowDirectiveAttribute = i, this.cellTagName = r, this.cellDirectiveAttribute = n, this.cellTagName = this.cellTagName.toUpperCase(), this.cells = null } return e.prototype.configureSection = function (e, t) { var i = this, r = this.getSectionElement(e, !0); r.empty(), r.removeAttr("ng-non-bindable"); var n = T(t, this.cells, !1, !1), l = this.getTemplatedRowElement(r, !0); return angular.forEach(n, function (e, t) { var r, n = e; r = n.parent === i && n.cellElement ? n.cellElement.clone(!0) : angular.element("<table><" + i.cellTagName + "></" + i.cellTagName + "></table>").find(i.cellTagName), i.cellDirectiveAttribute && r.attr(i.cellDirectiveAttribute, t), e.isStandardColumn || r.attr(g, "true"), e.fieldName && r.attr(o, e.fieldName), r.attr("ng-style", "{'width':columnOptions.cellWidth,'height':columnOptions.cellHeight}"), l.append(r) }), r }, e.prototype.extractPartialColumnDefinitions = function () { return this.cells }, e.prototype.discoverTemplates = function (e) { var t = this; this.cells = [], this.cellRow = null; var i = this.getTemplatedRowElement(this.getSectionElement(e, !1), !1); i && (this.cellRow = angular.element(i.clone()), this.cellRow.empty(), angular.forEach(i.children(), function (e, i) { if (e = angular.element(e), e[0].tagName === t.cellTagName.toUpperCase()) { var r = e.clone(); t.cells.push(new $(t, r)) } })) }, e.prototype.getSectionElement = function (e, t) { var i = null; return e && (i = x(e, this.sectionTagName)), !i && t && (i = angular.element("<table><" + this.sectionTagName + "></" + this.sectionTagName + "></table>").find(this.sectionTagName), e && e.append(i)), i && t && this.sectionDirectiveAttribute && i.attr(this.sectionDirectiveAttribute, ""), i }, e.prototype.getTemplatedRowElement = function (e, t) { var i = null; return e && (i = x(e, "tr")), !i && t && (i = this.cellRow ? angular.element(this.cellRow.clone()) : angular.element("<table><tr></tr></table>").find("tr"), e && e.append(i)), i && t && this.rowDirectiveAttribute && i.attr(this.rowDirectiveAttribute, ""), i }, e }(), A = function () { function t(e, t, r, l, a) { this.$compile = e, this.$parse = t, this.$timeout = r, n || (i(l, a), n = !0) } return t.prototype.setupGrid = function (t, i, n) { return this.gridOptions = i, this.isInServerSideMode = n, t.gridOptions = i, t.TrNgGrid = e, i.gridColumnDefs = [], void 0 === i.locale && (i.locale = "en"), void 0 === i.selectionMode && (i.selectionMode = r[r.MultiRow]), void 0 === i.filterByFields && (i.filterByFields = {}), void 0 === i.enableFiltering && (i.enableFiltering = !0), void 0 === i.enableSorting && (i.enableSorting = !0), void 0 === i.onDataRequiredDelay && (i.onDataRequiredDelay = 1e3), void 0 === i.selectedItems && (i.selectedItems = []), void 0 === i.currentPage && (i.currentPage = 0), this.setupServerSideModeTriggers(t), this.setupDataFilteringTriggers(t), this.setupDataFormattingTriggers(t), this.setupDataSelectionTriggers(t), t }, t.prototype.setupDataFilteringTriggers = function (e) { var t = this, i = !1; if (this.scheduleDataFiltering = function () { i || (e.$evalAsync(function () { i = !1, t.computeFilteredItems(e) }), i = !0) }, !this.isInServerSideMode) { var r = !0; e.$watchCollection("[gridOptions.filterBy,gridOptions.filterByFields,gridOptions.orderBy,gridOptions.orderByReverse,gridOptions.pageItems]", function (e, i) { r ? r = !1 : (t.gridOptions.currentPage = 0, t.scheduleDataFiltering()) }), e.$watch("gridOptions.currentPage", function (e, i) { e !== i && t.scheduleDataFiltering() }) } }, t.prototype.setupDataFormattingTriggers = function (t) { var i = this, r = !1; this.scheduleDataFormatting = function () { r || (t.$evalAsync(function () { r = !1, i.computeFormattedItems(t) }), r = !0) }; var n = "[gridOptions.items,gridOptions.gridColumnDefs.length"; angular.forEach(t.gridOptions.gridColumnDefs, function (e) { if (e.displayFormat && "." != e.displayFormat[0]) { var t = e.displayFormat.split("|"); angular.forEach(t, function (e) { var t = e.split(":"); t.length > 1 && angular.forEach(t.slice(1), function (e) { e = e.trim(), e && "gridItem" !== e && "gridDisplayItem" !== e && (n += "," + e) }) }) } }), n += "]", e.debugMode && this.log("re-formatting is set to watch for changes in " + n), t.$watch(n, function () { return i.scheduleDataFormatting() }, !0) }, t.prototype.setupServerSideModeTriggers = function (t) { var i = this; if (this.isInServerSideMode) { var r = null, n = !1, l = !1, a = !1, s = function () { r && (i.$timeout.cancel(r), r = null) }, o = function () { e.debugMode && i.log("Preparing to request data - server side mode"), s(); var r = function () { t.$applyAsync(function () { n = !1; try { e.debugMode && i.log("Requesting data - server side mode"), i.gridOptions.onDataRequired(i.gridOptions) } catch (t) { throw e.debugMode && i.log("Data retrieval failed " + t), t } }) }; a ? t.$evalAsync(function () { e.debugMode && i.log("Resetting the page index - server side mode"), t.gridOptions.currentPage = 0, a = !1, r() }) : r() }; this.scheduleServerSideModeDataRetrieval = function () { n || (s(), r = i.$timeout(function () { r = null, n = !0, o() }, i.gridOptions.onDataRequiredDelay, !0), l && i.speedUpServerSideModeDataRetrieval()) }, this.speedUpServerSideModeDataRetrieval = function (e) { e && 13 != e.keyCode || (r ? (l = !1, s(), n = !0, o()) : l = !0) }, t.$watch("gridOptions.currentPage", function (t, r) { t !== r && (e.debugMode && i.log("Changes detected in the current page index in server-side mode. Scheduling data retrieval..."), i.scheduleServerSideModeDataRetrieval()) }); var d = !0; t.$watchCollection("[gridOptions.filterBy, gridOptions.filterByFields, gridOptions.orderBy, gridOptions.orderByReverse, gridOptions.pageItems]", function (t, r) { d ? d = !1 : (0 !== i.gridOptions.currentPage && (e.debugMode && i.log("Changes detected in parameters in server-side mode. Requesting a page index reset..."), a = !0), e.debugMode && i.log("Changes detected in parameters in server-side mode. Scheduling data retrieval..."), i.scheduleServerSideModeDataRetrieval()) }), this.scheduleServerSideModeDataRetrieval(), this.speedUpServerSideModeDataRetrieval() } else this.speedUpServerSideModeDataRetrieval = function (e) { }; t.speedUpAsyncDataRetrieval = function (e) { return i.speedUpServerSideModeDataRetrieval(e) } }, t.prototype.setupDataSelectionTriggers = function (e) { var t = this; e.$watch("gridOptions.selectionMode", function (e, i) { if (e !== i) switch (e) { case r[r.None]: t.gridOptions.selectedItems.splice(0); break; case r[r.SingleRow]: t.gridOptions.selectedItems.length > 1 && t.gridOptions.selectedItems.splice(1) } }) }, t.prototype.setColumnOptions = function (e, t) { var i = this.gridOptions.gridColumnDefs[e]; if (!i) throw "Invalid grid column options found for column index " + e + ". Please report this error."; t = angular.extend(t, i), this.gridOptions.gridColumnDefs[e] = t }, t.prototype.toggleSorting = function (e) { this.gridOptions.orderBy != e ? this.gridOptions.orderBy = e : this.gridOptions.orderByReverse = !this.gridOptions.orderByReverse, this.speedUpServerSideModeDataRetrieval() }, t.prototype.toggleItemSelection = function (e, t, i) { if (this.gridOptions.selectionMode !== r[r.None]) switch (this.gridOptions.selectionMode) { case r[r.MultiRowWithKeyModifiers]: if (i.ctrlKey || i.shiftKey || i.metaKey) { if (i.ctrlKey || i.metaKey) { var n = this.gridOptions.selectedItems.indexOf(t); n >= 0 ? this.gridOptions.selectedItems.splice(n, 1) : this.gridOptions.selectedItems.push(t) } else if (i.shiftKey) { if (document.selection && document.selection.empty) document.selection.empty(); else if (window.getSelection) { var l = window.getSelection(); l.removeAllRanges() } var a, s = this.gridOptions.selectedItems[this.gridOptions.selectedItems.length - 1]; for (a = 0; a < e.length && e[a].$$_gridItem !== s; a++); a >= e.length && (a = 0); var o; for (o = 0; o < e.length && e[o].$$_gridItem !== t; o++); if (o >= e.length) throw "Invalid selection on a key modifier selection mode"; if (a > o) { var d = a; a = o, o = d } for (var g = a; o >= g; g++) { var c = e[g].$$_gridItem; this.gridOptions.selectedItems.indexOf(c) < 0 && this.gridOptions.selectedItems.push(c) } } } else { var n = this.gridOptions.selectedItems.indexOf(t); this.gridOptions.selectedItems.splice(0), 0 > n && this.gridOptions.selectedItems.push(t) } break; case r[r.SingleRow]: var n = this.gridOptions.selectedItems.indexOf(t); this.gridOptions.selectedItems.splice(0), 0 > n && this.gridOptions.selectedItems.push(t); break; case r[r.MultiRow]: var n = this.gridOptions.selectedItems.indexOf(t); n >= 0 ? this.gridOptions.selectedItems.splice(n, 1) : this.gridOptions.selectedItems.push(t) } }, t.prototype.discoverTemplates = function (e) { this.templatedHeader = new N("thead", null, null, "th", I), this.templatedBody = new N("tbody", s, null, "td", F), this.templatedFooter = new N("tfoot", null, null, "td", u), this.templatedHeader.discoverTemplates(e), this.templatedFooter.discoverTemplates(e), this.templatedBody.discoverTemplates(e) }, t.prototype.getSafeFieldName = function (e) { return e.replace(/[^a-zA-Z0-9]/g, "_") }, t.prototype.configureTableStructure = function (t, i, r) { var n = this; try { if (i.empty(), r) { var l = r; this.$timeout(function () { l.$destroy() }), r = null } var a = t.$new(); this.columnDefsItemsWatcherDeregistration && (this.columnDefsItemsWatcherDeregistration(), this.columnDefsItemsWatcherDeregistration = null), this.columnDefsFieldsWatcherDeregistration && (this.columnDefsFieldsWatcherDeregistration(), this.columnDefsFieldsWatcherDeregistration = null), this.columnDefsFieldsWatcherDeregistration = a.$watch("gridOptions.fields", function (e, r) { angular.equals(e, r) || n.configureTableStructure(t, i, a) }, !0); var o = this.templatedHeader.extractPartialColumnDefinitions(), d = this.templatedBody.extractPartialColumnDefinitions(), g = this.templatedFooter.extractPartialColumnDefinitions(), c = [], u = this.gridOptions.fields; if (u) angular.forEach(this.gridOptions.fields, function (e) { e && c.push({ isStandardColumn: !0, fieldName: e }) }), c = T(c, o, !1, !0), c = T(c, d, !1, !0); else if (o.length > 0) c = T(o, d, !0, !0); else { if (!this.gridOptions.items || 0 == this.gridOptions.items.length) return void (this.columnDefsItemsWatcherDeregistration = a.$watch("gridOptions.items.length", function (e, r) { e && n.configureTableStructure(t, i, a) })); for (var p in this.gridOptions.items[0]) c.push({ isStandardColumn: !0, fieldName: p }); c = T(c, d, !0, !0) } 0 == g.length && g.push({ isStandardColumn: !0 }), angular.forEach(c, function (e) { if (e.fieldName) { var t = e.fieldName; e.displayFieldName = n.getSafeFieldName(t); var i; i = "[" === t[0] ? t : t.replace(/^([^\.]+)/g, '["$1"]'), e.fieldExtractionExpression = i } }), this.gridOptions.gridColumnDefs = c; var m = this.templatedHeader.configureSection(i, c), f = this.templatedFooter.configureSection(i, g), h = this.templatedBody.configureSection(i, c), v = this.templatedBody.getTemplatedRowElement(h); this.templatedHeader.getTemplatedRowElement(m); h.attr(s, ""), v.attr("ng-click", "toggleItemSelection(gridItem, $event)"), v.attr("ng-repeat", "gridDisplayItem in filteredItems"), v.attr("ng-init", "gridItem=gridDisplayItem.$$_gridItem;" + v.attr("ng-init")); var I = v.attr("ng-class"); I = (I || "").replace(/^(\s*\{?)(.*?)(\}?\s*)$/, "{'" + e.rowSelectedCssClass + "':gridOptions.selectedItems.indexOf(gridItem) >= 0, $2}"), v.attr("ng-class", I), this.$compile(m)(a), this.$compile(f)(a), this.$compile(h)(a) } catch (y) { throw e.debugMode && this.log("Fixing table structure failed with error " + y), y } }, t.prototype.computeFormattedItems = function (t) { var i = t.gridOptions.items || []; e.debugMode && this.log("formatting items of length " + i.length); try { for (var r = t.formattedItems = t.formattedItems || [], n = t.gridOptions.gridColumnDefs, l = 0; l < i.length; l++) { for (var a, s = i[l], o = { gridItem: s }; r.length > i.length && (a = r[l]).$$_gridItem !== s;) r.splice(l, 1); l < r.length ? (a = r[l], a.$$_gridItem !== s && (a = { $$_gridItem: s }, r[l] = a)) : (a = { $$_gridItem: s }, r.push(a)); for (var d = 0; d < n.length; d++) { var g; try { var c = n[d]; if (c.displayFieldName && c.fieldExtractionExpression) { var u = c.displayFormat; u && "." !== u[0] && "|" !== u[0] && "[" !== u[0] && (u = " | " + u), a[c.displayFieldName] = t.$eval("gridItem" + c.fieldExtractionExpression + (u || ""), o) } } catch (p) { e.debugMode && this.log("Field evaluation failed for <" + (g || "unknown") + "> with error " + p) } } } r.length > i.length && r.splice(i.length, r.length - i.length), this.scheduleDataFiltering() } catch (p) { throw e.debugMode && this.log("Failed to format items " + p), p } }, t.prototype.extractDataItems = function (e) { var t; if (e) { t = new Array(e.length); for (var i = 0; i < e.length; i++) t[i] = e[i].$$_gridItem } else t = []; return t }, t.prototype.computeFilteredItems = function (t) { try { if (this.isInServerSideMode) t.filteredItems = t.formattedItems; else { if (t.filterByDisplayFields = {}, t.gridOptions.filterByFields) for (var i in t.gridOptions.filterByFields) t.filterByDisplayFields[this.getSafeFieldName(i)] = t.gridOptions.filterByFields[i]; e.debugMode && this.log("filtering items of length " + (t.formattedItems ? t.formattedItems.length : 0)), t.filteredItems = t.$eval("formattedItems | filter:gridOptions.filterBy | filter:filterByDisplayFields | " + e.sortFilter + ":gridOptions"), t.gridOptions.filteredItems && (t.gridOptions.filteredItems = this.extractDataItems(t.filteredItems)), t.filteredItems = t.$eval("filteredItems | " + e.dataPagingFilter + ":gridOptions") } t.gridOptions.filteredItemsPage && (t.gridOptions.filteredItemsPage = this.extractDataItems(t.filteredItems)) } catch (r) { throw e.debugMode && this.log("Failed to filter items " + r), r } }, t.prototype.linkAttrs = function (e, t) { var i = function (e, i) { if ("undefined" != typeof i) { switch (i) { case "true": i = !0; break; case "false": i = !1 } t[e] = i } }; for (var r in t) i(r, e[r]), function (t) { e.$observe(t, function (e) { return i(t, e) }) }(r) }, t.prototype.log = function (e) { console.log(l + "(" + (new Date).getTime() + "): " + e) }, t }(); angular.module("trNgGrid", []).directive(l, [function () { return { restrict: "A", scope: { items: "=", selectedItems: "=?", filteredItems: "=?", filteredItemsPage: "=?", filterBy: "=?", filterByFields: "=?", orderBy: "=?", orderByReverse: "=?", pageItems: "=?", currentPage: "=?", totalItems: "=?", enableFiltering: "=?", enableSorting: "=?", selectionMode: "@", locale: "@", onDataRequired: "&", onDataRequiredDelay: "=?", fields: "=?" }, controller: ["$compile", "$parse", "$timeout", "$templateCache", "$interpolate", A], compile: function (t, i) { return angular.forEach(t.children(), function (e) { e = angular.element(e), e.attr("ng-non-bindable", "") }), { pre: function (e, t, i, r, n) { r.discoverTemplates(t) }, post: function (t, i, r, n, l) { i.addClass(e.tableCssClass); var a = t.$parent.$new(); n.setupGrid(a, t, !!r.onDataRequired), n.configureTableStructure(a, i), t.$on("$destroy", function () { a.$destroy(), e.debugMode && n.log("grid scope destroyed") }) } } } } }]).directive(v, [function () { var t = function (e) { if (e.columnOptions.displayName) e.columnTitle = e.columnOptions.displayName; else if (e.columnOptions.fieldName) { var t = e.columnOptions.fieldName.replace(/^([^\a-zA-Z]*)([\a-zA-Z0-9]*)(.*)/g, "$2"), i = t.split(/(?=[A-Z])/); i.length && i[0].length && (i[0] = i[0][0].toLocaleUpperCase() + i[0].substr(1)), e.columnTitle = i.join(" ") } else e.columnTitle = "" }; return { restrict: "A", require: "^" + l, scope: !0, compile: function (i, r) { var n = "true" == r.isCustomized; return P(i, r, n, O), { pre: function (i, r, l, a, s) { var o = parseInt(l[v]), d = angular.extend(i.gridOptions.gridColumnDefs[o], e.defaultColumnOptionsTemplate, e.defaultColumnOptions); a.linkAttrs(l, d), i.columnOptions = d, i.isCustomized = n, i.toggleSorting = function (e) { a.toggleSorting(e) }, i.$watch("columnOptions.displayName", function () { t(i) }); var g = !1; i.$watch("gridOptions.filterByFields['" + d.fieldName + "']", function (e, t) { d.filter !== e && (d.filter = e), g || (i.$watch("columnOptions.filter", function (e, t) { i.gridOptions.filterByFields[d.fieldName] !== e && (e ? i.gridOptions.filterByFields[d.fieldName] = e : delete i.gridOptions.filterByFields[d.fieldName], i.gridOptions.filterByFields = angular.extend({}, i.gridOptions.filterByFields)) }), g = !0) }) } } } } }]).directive(y, [function () { return { restrict: "A", templateUrl: e.cellHeaderTemplateId, transclude: !0, replace: !0 } }]).directive(a, [function () { return { restrict: "A", require: "^" + l, scope: !0, compile: function (e, t) { return { pre: function (e, t, i, r) { e.toggleItemSelection = function (t, i) { r.toggleItemSelection(e.filteredItems, t, i) } } } } } }]).directive(C, [function () { return { restrict: "A", require: "^" + l, scope: !0, compile: function (e, t) { var i = "true" == t.isCustomized; return P(e, t, i, S), { pre: function (e, t, r, n, l) { e.columnOptions = e.gridOptions.gridColumnDefs[parseInt(r[C])], e.gridItem = e.gridDisplayItem.$$_gridItem, e.isCustomized = i } } } } }]).directive(D, [function () { return { restrict: "A", templateUrl: e.cellBodyTemplateId, transclude: !0, replace: !0 } }]).directive(c, [function () { return { restrict: "A", require: "^" + l, scope: !0, compile: function (e, t) { var i = "true" == t.isCustomized; return P(e, t, i, m), { pre: function (e, t, r, n, l) { e.isCustomized = i, t.attr("colspan", e.gridOptions.gridColumnDefs.length) } } } } }]).directive(p, [function () { return { restrict: "A", templateUrl: e.cellFooterTemplateId, transclude: !0, replace: !0 } }]).directive(b, [function () { return { restrict: "A", replace: !0, templateUrl: e.columnSortTemplateId } }]).directive(w, [function () { return { restrict: "A", replace: !0, templateUrl: e.columnFilterTemplateId } }]).directive(f, [function () { return { restrict: "A", scope: !1, templateUrl: e.footerGlobalFilterTemplateId } }]).directive(h, [function () { var t = function (t, i) { if (t.totalItemsCount = "undefined" != typeof t.gridOptions.totalItems && null != t.gridOptions.totalItems ? t.gridOptions.totalItems : t.gridOptions.items ? t.gridOptions.items.length : 0, t.isPaged = !!t.gridOptions.pageItems && t.gridOptions.pageItems < t.totalItemsCount, t.extendedControlsActive = !1, t.lastPageIndex = t.totalItemsCount && t.isPaged ? Math.floor(t.totalItemsCount / t.gridOptions.pageItems) + (t.totalItemsCount % t.gridOptions.pageItems ? 0 : -1) : 0, t.gridOptions.currentPage > t.lastPageIndex && (e.debugMode && i.log("The current page index falls outside of the range of items. Either the attached parameter has a wrong value or the total items count is not properly set in server side mode."), t.gridOptions.currentPage = t.lastPageIndex), t.startItemIndex = t.isPaged ? t.gridOptions.pageItems * t.gridOptions.currentPage : 0, t.endItemIndex = t.isPaged ? t.startItemIndex + t.gridOptions.pageItems - 1 : t.totalItemsCount - 1, t.endItemIndex >= t.totalItemsCount && (t.endItemIndex = t.totalItemsCount - 1), t.endItemIndex < t.startItemIndex && (t.endItemIndex = t.startItemIndex), t.pageCanGoBack = t.isPaged && t.gridOptions.currentPage > 0, t.pageCanGoForward = t.isPaged && t.gridOptions.currentPage < t.lastPageIndex, t.pageIndexes = t.pageIndexes || [], t.pageIndexes.splice(0), t.isPaged) if (t.lastPageIndex + 1 > e.defaultPagerMinifiedPageCountThreshold) { t.extendedControlsActive = !0; var r = Math.floor(e.defaultPagerMinifiedPageCountThreshold / 2), n = t.gridOptions.currentPage - r, l = t.gridOptions.currentPage + r; 0 > n ? (l += -n, n = 0) : l > t.lastPageIndex && (n -= l - t.lastPageIndex, l = t.lastPageIndex), n > 0 && (t.pageIndexes.push(null), n++); var a = !1; l < t.lastPageIndex && (a = !0, l--); for (var s = n; l >= s; s++) t.pageIndexes.push(s); a && t.pageIndexes.push(null) } else { t.extendedControlsActive = !1; for (var s = 0; s <= t.lastPageIndex; s++) t.pageIndexes.push(s) } t.pageSelectionActive = t.pageIndexes.length > 1, t.navigateToPage = function (e) { t.gridOptions.currentPage = e, t.speedUpAsyncDataRetrieval() }, t.switchPageSelection = function (e, i) { t.pageSelectionActive = i, e && (e.preventDefault(), e.stopPropagation()) } }; return { restrict: "A", scope: !0, require: "^" + l, templateUrl: e.footerPagerTemplateId, replace: !0, compile: function (e, i) { return { pre: function (e, i, r, n) { t(e, n) }, post: function (e, i, r, n) { e.$watchCollection("[gridOptions.currentPage, gridOptions.items.length, gridOptions.totalItems, gridOptions.pageItems]", function (i, r) { t(e, n) }) } } } } }]).filter(e.sortFilter, ["$filter", "$parse", function (e, t) { return function (i, r) { if (!r.orderBy || !r.gridColumnDefs) return i; for (var n = null, l = 0; l < r.gridColumnDefs.length && (n = r.gridColumnDefs[l]).fieldName !== r.orderBy; n = null, l++); if (!n) return i; var a = e("orderBy")(i, function (e) { var i = void 0; if (n.fieldExtractionExpression) try { i = t("item.$$_gridItem" + n.fieldExtractionExpression)({ item: e }) } catch (r) { } if (void 0 === i) try { i = t('item["' + n.displayFieldName + '"]')({ item: e }) } catch (r) { } return i }, r.orderByReverse); return a } }]).filter(e.dataPagingFilter, function () { return function (e, t) { if (e && (t.totalItems = e.length), !t.pageItems || !e || 0 == e.length) return e; t.currentPage || (t.currentPage = 0); var i = t.currentPage * t.pageItems; i >= e.length && (t.currentPage = 0, i = 0); var r = t.currentPage * t.pageItems + t.pageItems; return e.slice(i, r) } }).filter(e.translateFilter, ["$filter", "$injector", function (t, i) { return function (r, n) { var l = null; if (!n) throw "Language identifier is not set"; if (r instanceof Date) { var a = t(e.translateFilter)(e.translationDateFormat, n); return a && a !== e.translationDateFormat ? l = t("date")(r, a) : r } for (var s = n.split(/[-_]/), o = s.length; o > 0 && !l; o--) { var d = s.slice(0, o).join("-"), g = e.translations[d]; g && (l = g[r]) } if (!l && i.has("translateFilter")) try { l = t("translate")(r) } catch (c) { } return l || (l = r), l } }]).run(function () { e.tableCssClass = "tr-ng-grid table table-bordered table-hover", e.cellCssClass = "tr-ng-cell", e.headerCellCssClass = "tr-ng-column-header " + e.cellCssClass, e.bodyCellCssClass = e.cellCssClass, e.columnTitleCssClass = "tr-ng-title", e.columnSortCssClass = "tr-ng-sort", e.columnFilterCssClass = "tr-ng-column-filter", e.columnFilterInputWrapperCssClass = "", e.columnSortActiveCssClass = "tr-ng-sort-active text-info", e.columnSortInactiveCssClass = "tr-ng-sort-inactive text-muted glyphicon glyphicon-chevron-down", e.columnSortReverseOrderCssClass = "tr-ng-sort-order-reverse glyphicon glyphicon-chevron-down", e.columnSortNormalOrderCssClass = "tr-ng-sort-order-normal glyphicon glyphicon-chevron-up", e.rowSelectedCssClass = "active", e.footerCssClass = "tr-ng-grid-footer form-inline" }).run(function () { e.defaultColumnOptions.displayAlign = "left", e.defaultPagerMinifiedPageCountThreshold = 3 }) }(TrNgGrid || (TrNgGrid = {}));

/*========================================================================*/
/*                    TrNgGrid version 3.1.7                              */
/*   -------------------------------------------------------------        */
/* THIS FILE WAS GENERATED VIA GULP. DO NOT MODIFY THIS FILE MANUALLY.    */
/*======================================================================= */
"use strict";
var TrNgGrid;
(function (TrNgGrid) {
    (function (SelectionMode) {
        SelectionMode[SelectionMode["None"] = 0] = "None";
        SelectionMode[SelectionMode["SingleRow"] = 1] = "SingleRow";
        SelectionMode[SelectionMode["MultiRow"] = 2] = "MultiRow";
        SelectionMode[SelectionMode["MultiRowWithKeyModifiers"] = 3] = "MultiRowWithKeyModifiers";
    })(TrNgGrid.SelectionMode || (TrNgGrid.SelectionMode = {}));
    var SelectionMode = TrNgGrid.SelectionMode;
    TrNgGrid.defaultColumnOptionsTemplate = {
        cellWidth: null,
        cellHeight: null,
        displayAlign: null,
        displayFormat: null,
        displayName: null,
        filter: null,
        enableFiltering: null,
        enableSorting: null
    };
    TrNgGrid.defaultColumnOptions = {};
    TrNgGrid.translations = {};
    TrNgGrid.debugMode = false;
    var templatesConfigured = false;
    var tableDirective = "trNgGrid";
    TrNgGrid.sortFilter = tableDirective + "SortFilter";
    TrNgGrid.dataPagingFilter = tableDirective + "DataPagingFilter";
    TrNgGrid.translateFilter = tableDirective + "TranslateFilter";
    TrNgGrid.translationDateFormat = tableDirective + "DateFormat";
    TrNgGrid.dataFormattingFilter = tableDirective + "DataFormatFilter";
    var bodyDirective = "trNgGridBody";
    var bodyDirectiveAttribute = "tr-ng-grid-body";
    var fieldNameAttribute = "field-name";
    var altFieldNameAttribute = "data-field-name";
    var isCustomizedAttribute = "is-customized";
    var cellFooterDirective = "trNgGridFooterCell";
    var cellFooterDirectiveAttribute = "tr-ng-grid-footer-cell";
    var cellFooterTemplateDirective = "trNgGridFooterCellTemplate";
    var cellFooterTemplateDirectiveAttribute = "tr-ng-grid-footer-cell-template";
    TrNgGrid.cellFooterTemplateId = cellFooterTemplateDirective + ".html";
    var globalFilterDirective = "trNgGridGlobalFilter";
    TrNgGrid.globalFilterDirectiveAttribute = "tr-ng-grid-global-filter";
    TrNgGrid.footerGlobalFilterTemplateId = globalFilterDirective + ".html";
    var pagerDirective = "trNgGridPager";
    TrNgGrid.pagerDirectiveAttribute = "tr-ng-grid-pager";
    TrNgGrid.footerPagerTemplateId = pagerDirective + ".html";
    var cellHeaderDirective = "trNgGridHeaderCell";
    var cellHeaderDirectiveAttribute = "tr-ng-grid-header-cell";
    var cellHeaderTemplateDirective = "trNgGridHeaderCellTemplate";
    var cellHeaderTemplateDirectiveAttribute = "tr-ng-grid-header-cell-template";
    TrNgGrid.cellHeaderTemplateId = cellHeaderTemplateDirective + ".html";
    var cellBodyDirective = "trNgGridBodyCell";
    var cellBodyDirectiveAttribute = "tr-ng-grid-body-cell";
    var cellBodyTemplateDirective = "trNgGridBodyCellTemplate";
    var cellBodyTemplateDirectiveAttribute = "tr-ng-grid-body-cell-template";
    TrNgGrid.cellBodyTemplateId = cellBodyTemplateDirective + ".html";
    var columnSortDirective = "trNgGridColumnSort";
    TrNgGrid.columnSortDirectiveAttribute = "tr-ng-grid-column-sort";
    TrNgGrid.columnSortTemplateId = columnSortDirective + ".html";
    var columnFilterDirective = "trNgGridColumnFilter";
    TrNgGrid.columnFilterDirectiveAttribute = "tr-ng-grid-column-filter";
    TrNgGrid.columnFilterTemplateId = columnFilterDirective + ".html";
    var findChildByTagName = function (parent, childTag) {
        childTag = childTag.toUpperCase();
        var children = parent.children();
        for (var childIndex = 0; childIndex < children.length; childIndex++) {
            var childElement = children[childIndex];
            if (childElement.tagName == childTag) {
                return angular.element(childElement);
            }
        }
        return null;
    };
    var findChildrenByTagName = function (parent, childTag) {
        childTag = childTag.toUpperCase();
        var retChildren = [];
        var children = parent.children();
        for (var childIndex = 0; childIndex < children.length; childIndex++) {
            var childElement = children[childIndex];
            if (childElement.tagName === childTag) {
                retChildren.push(angular.element(childElement));
            }
        }
        return retChildren;
    };
    var combineGridCellInfos = function (firstSet, secondSet, addExtraFieldItemsSecondSet, addExtraNonFieldItemsSecondSet) {
        var combinedSet = [];
        var secondTempSet = secondSet.slice(0);
        angular.forEach(firstSet, function (firstSetColumn) {
            var foundSecondSetColumn = null;
            for (var secondSetColumnIndex = 0; !foundSecondSetColumn && secondSetColumnIndex < secondTempSet.length; secondSetColumnIndex++) {
                foundSecondSetColumn = secondTempSet[secondSetColumnIndex];
                if (foundSecondSetColumn.fieldName === firstSetColumn.fieldName) {
                    secondTempSet.splice(secondSetColumnIndex, 1);
                }
                else {
                    foundSecondSetColumn = null;
                }
            }
            if (foundSecondSetColumn) {
                combinedSet.push(foundSecondSetColumn);
            }
            else {
                combinedSet.push(firstSetColumn);
            }
        });
        if (addExtraFieldItemsSecondSet || addExtraNonFieldItemsSecondSet) {
            angular.forEach(secondTempSet, function (secondSetColumn) {
                if ((addExtraFieldItemsSecondSet && secondSetColumn.fieldName) || (addExtraNonFieldItemsSecondSet && !secondSetColumn.fieldName)) {
                    combinedSet.push(secondSetColumn);
                }
            });
        }
        return combinedSet;
    };
    var wrapTemplatedCell = function (templateElement, tAttrs, isCustomized, cellTemplateDirective) {
        if (isCustomized) {
            var childrenElements = templateElement.children();
            var firstChildElement = angular.element(childrenElements[0]);
            if (childrenElements.length !== 1 || !firstChildElement.attr(cellTemplateDirective)) {
                templateElement.empty();
                var templateWrapElement = angular.element("<div></div>").attr(cellTemplateDirective, "");
                templateElement.append(templateWrapElement);
                angular.forEach(childrenElements, function (childElement) {
                    templateWrapElement.append(angular.element(childElement));
                });
            }
        }
        else {
            templateElement.empty();
            templateElement.append(angular.element("<div></div>").attr(cellTemplateDirective, ""));
        }
    };
    var TemplatedCell = (function () {
        function TemplatedCell(parent, cellElement) {
            this.parent = parent;
            this.cellElement = cellElement;
            this.fieldName = cellElement.attr(fieldNameAttribute) || cellElement.attr(altFieldNameAttribute);
            var customContent = cellElement.children();
            this.isStandardColumn = customContent.length === 0;
        }
        return TemplatedCell;
    })();
    var TemplatedSection = (function () {
        function TemplatedSection(sectionTagName, sectionDirectiveAttribute, rowDirectiveAttribute, cellTagName, cellDirectiveAttribute) {
            this.sectionTagName = sectionTagName;
            this.sectionDirectiveAttribute = sectionDirectiveAttribute;
            this.rowDirectiveAttribute = rowDirectiveAttribute;
            this.cellTagName = cellTagName;
            this.cellDirectiveAttribute = cellDirectiveAttribute;
            this.cellTagName = this.cellTagName.toUpperCase();
            this.cells = null;
        }
        TemplatedSection.prototype.configureSection = function (gridElement, columnDefs) {
            var _this = this;
            var sectionElement = this.getSectionElement(gridElement, true);
            sectionElement.empty();
            sectionElement.removeAttr("ng-non-bindable");
            var rowElementDefinitions = combineGridCellInfos(columnDefs, this.cells, false, false);
            var templatedRowElement = this.getTemplatedRowElement(sectionElement, true);
            angular.forEach(rowElementDefinitions, function (gridCell, index) {
                var gridCellElement;
                var templatedCell = gridCell;
                if (templatedCell.parent === _this && templatedCell.cellElement) {
                    gridCellElement = templatedCell.cellElement.clone(true);
                }
                else {
                    gridCellElement = angular.element("<table><" + _this.cellTagName + "></" + _this.cellTagName + "></table>").find(_this.cellTagName);
                }
                if (_this.cellDirectiveAttribute) {
                    gridCellElement.attr(_this.cellDirectiveAttribute, index);
                }
                if (!gridCell.isStandardColumn) {
                    gridCellElement.attr(isCustomizedAttribute, "true");
                }
                if (gridCell.fieldName) {
                    gridCellElement.attr(fieldNameAttribute, gridCell.fieldName);
                }
                gridCellElement.attr("ng-style", "{\'width\':columnOptions.cellWidth,\'height\':columnOptions.cellHeight}");
                templatedRowElement.append(gridCellElement);
            });
            return sectionElement;
        };
        TemplatedSection.prototype.extractPartialColumnDefinitions = function () {
            return this.cells;
        };
        TemplatedSection.prototype.discoverTemplates = function (gridElement) {
            var _this = this;
            this.cells = [];
            this.cellRow = null;
            var templatedRow = this.getTemplatedRowElement(this.getSectionElement(gridElement, false), false);
            if (templatedRow) {
                this.cellRow = angular.element(templatedRow.clone());
                this.cellRow.empty();
                angular.forEach(templatedRow.children(), function (childElement, childIndex) {
                    childElement = angular.element(childElement);
                    if (childElement[0].tagName === _this.cellTagName.toUpperCase()) {
                        var templateElement = childElement.clone();
                        _this.cells.push(new TemplatedCell(_this, templateElement));
                    }
                });
            }
        };
        TemplatedSection.prototype.getSectionElement = function (gridElement, ensurePresent) {
            var sectionElement = null;
            if (gridElement) {
                sectionElement = findChildByTagName(gridElement, this.sectionTagName);
            }
            if (!sectionElement && ensurePresent) {
                sectionElement = angular.element("<table><" + this.sectionTagName + "></" + this.sectionTagName + "></table>").find(this.sectionTagName);
                if (gridElement) {
                    gridElement.append(sectionElement);
                }
            }
            if (sectionElement && ensurePresent && this.sectionDirectiveAttribute) {
                sectionElement.attr(this.sectionDirectiveAttribute, "");
            }
            return sectionElement;
        };
        TemplatedSection.prototype.getTemplatedRowElement = function (sectionElement, ensurePresent) {
            var rowElement = null;
            if (sectionElement) {
                rowElement = findChildByTagName(sectionElement, "tr");
            }
            if (!rowElement && ensurePresent) {
                rowElement = this.cellRow ? angular.element(this.cellRow.clone()) : angular.element("<table><tr></tr></table>").find("tr");
                if (sectionElement) {
                    sectionElement.append(rowElement);
                }
            }
            if (rowElement && ensurePresent && this.rowDirectiveAttribute) {
                rowElement.attr(this.rowDirectiveAttribute, "");
            }
            return rowElement;
        };
        return TemplatedSection;
    })();
    var GridController = (function () {
        function GridController($compile, $parse, $timeout, $templateCache, $interpolate) {
            this.$compile = $compile;
            this.$parse = $parse;
            this.$timeout = $timeout;
            if (!templatesConfigured) {
                configureTemplates($templateCache, $interpolate);
                templatesConfigured = true;
            }
        }
        GridController.prototype.setupGrid = function (gridScope, gridOptions, isInServerSideMode) {
            this.gridOptions = gridOptions;
            this.isInServerSideMode = isInServerSideMode;
            gridScope.gridOptions = gridOptions;
            gridScope.TrNgGrid = TrNgGrid;
            gridOptions.gridColumnDefs = [];
            if (gridOptions.locale === undefined) {
                gridOptions.locale = "en";
            }
            if (gridOptions.selectionMode === undefined) {
                gridOptions.selectionMode = SelectionMode[SelectionMode.MultiRow];
            }
            if (gridOptions.filterByFields === undefined) {
                gridOptions.filterByFields = {};
            }
            if (gridOptions.enableFiltering === undefined) {
                gridOptions.enableFiltering = true;
            }
            if (gridOptions.enableSorting === undefined) {
                gridOptions.enableSorting = true;
            }
            if (gridOptions.onDataRequiredDelay === undefined) {
                gridOptions.onDataRequiredDelay = 1000;
            }
            if (gridOptions.selectedItems === undefined) {
                gridOptions.selectedItems = [];
            }
            if (gridOptions.currentPage === undefined) {
                gridOptions.currentPage = 0;
            }
            this.setupServerSideModeTriggers(gridScope);
            this.setupDataFilteringTriggers(gridScope);
            this.setupDataFormattingTriggers(gridScope);
            this.setupDataSelectionTriggers(gridScope);
            return gridScope;
        };
        GridController.prototype.setupDataFilteringTriggers = function (gridScope) {
            var _this = this;
            var scheduledForCurrentCycle = false;
            this.scheduleDataFiltering = function () {
                if (scheduledForCurrentCycle) {
                    return;
                }
                gridScope.$evalAsync(function () {
                    scheduledForCurrentCycle = false;
                    _this.computeFilteredItems(gridScope);
                });
                scheduledForCurrentCycle = true;
            };
            if (!this.isInServerSideMode) {
                var initCycle = true;
                gridScope.$watchCollection("[" +
                    "gridOptions.filterBy," +
                    "gridOptions.filterByFields," +
                    "gridOptions.orderBy," +
                    "gridOptions.orderByReverse," +
                    "gridOptions.pageItems" +
                    "]", function (newValue, oldValue) {
                        if (initCycle) {
                            initCycle = false;
                        }
                        else {
                            _this.gridOptions.currentPage = 0;
                            _this.scheduleDataFiltering();
                        }
                    });
                gridScope.$watch("gridOptions.currentPage", function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        {
                            _this.scheduleDataFiltering();
                        }
                    }
                });
            }
        };
        GridController.prototype.setupDataFormattingTriggers = function (gridScope) {
            var _this = this;
            var scheduledForCurrentCycle = false;
            this.scheduleDataFormatting = function () {
                if (scheduledForCurrentCycle) {
                    return;
                }
                gridScope.$evalAsync(function () {
                    scheduledForCurrentCycle = false;
                    _this.computeFormattedItems(gridScope);
                });
                scheduledForCurrentCycle = true;
            };
            var watchExpression = "[gridOptions.items,gridOptions.gridColumnDefs.length";
            angular.forEach(gridScope.gridOptions.gridColumnDefs, function (gridColumnDef) {
                if (gridColumnDef.displayFormat && gridColumnDef.displayFormat[0] != '.') {
                    var displayfilters = gridColumnDef.displayFormat.split('|');
                    angular.forEach(displayfilters, function (displayFilter) {
                        var displayFilterParams = displayFilter.split(':');
                        if (displayFilterParams.length > 1) {
                            angular.forEach(displayFilterParams.slice(1), function (displayFilterParam) {
                                displayFilterParam = displayFilterParam.trim();
                                if (displayFilterParam && displayFilterParam !== "gridItem" && displayFilterParam !== "gridDisplayItem") {
                                    watchExpression += "," + displayFilterParam;
                                }
                            });
                        }
                    });
                }
            });
            watchExpression += "]";
            TrNgGrid.debugMode && this.log("re-formatting is set to watch for changes in " + watchExpression);
            gridScope.$watch(watchExpression, function () { return _this.scheduleDataFormatting(); }, true);
        };
        GridController.prototype.setupServerSideModeTriggers = function (gridScope) {
            var _this = this;
            if (this.isInServerSideMode) {
                var dataRequestPromise = null;
                var scheduledForCurrentCycle = false;
                var fastNextSchedule = false;
                var pageIndexResetRequired = false;
                var cancelDataRequestPromise = function () {
                    if (dataRequestPromise) {
                        _this.$timeout.cancel(dataRequestPromise);
                        dataRequestPromise = null;
                    }
                };
                var retrieveDataCallback = function () {
                    TrNgGrid.debugMode && _this.log("Preparing to request data - server side mode");
                    cancelDataRequestPromise();
                    var requestData = function () {
                        gridScope.$applyAsync(function () {
                            scheduledForCurrentCycle = false;
                            try {
                                TrNgGrid.debugMode && _this.log("Requesting data - server side mode");
                                _this.gridOptions.onDataRequired(_this.gridOptions);
                            }
                            catch (ex) {
                                TrNgGrid.debugMode && _this.log("Data retrieval failed " + ex);
                                throw ex;
                            }
                        });
                    };
                    if (pageIndexResetRequired) {
                        gridScope.$evalAsync(function () {
                            TrNgGrid.debugMode && _this.log("Resetting the page index - server side mode");
                            gridScope.gridOptions.currentPage = 0;
                            pageIndexResetRequired = false;
                            requestData();
                        });
                    }
                    else {
                        requestData();
                    }
                };
                this.scheduleServerSideModeDataRetrieval = function () {
                    if (scheduledForCurrentCycle) {
                        return;
                    }
                    cancelDataRequestPromise();
                    dataRequestPromise = _this.$timeout(function () {
                        dataRequestPromise = null;
                        scheduledForCurrentCycle = true;
                        retrieveDataCallback();
                    }, _this.gridOptions.onDataRequiredDelay, true);
                    if (fastNextSchedule) {
                        _this.speedUpServerSideModeDataRetrieval();
                    }
                };
                this.speedUpServerSideModeDataRetrieval = function ($event) {
                    if (!$event || $event["keyCode"] == 13) {
                        if (dataRequestPromise) {
                            fastNextSchedule = false;
                            cancelDataRequestPromise();
                            scheduledForCurrentCycle = true;
                            retrieveDataCallback();
                        }
                        else {
                            fastNextSchedule = true;
                        }
                    }
                };
                gridScope.$watch("gridOptions.currentPage", function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        {
                            TrNgGrid.debugMode && _this.log("Changes detected in the current page index in server-side mode. Scheduling data retrieval...");
                            _this.scheduleServerSideModeDataRetrieval();
                        }
                    }
                });
                var initCycle = true;
                gridScope.$watchCollection("[" +
                    "gridOptions.filterBy, " +
                    "gridOptions.filterByFields, " +
                    "gridOptions.orderBy, " +
                    "gridOptions.orderByReverse, " +
                    "gridOptions.pageItems" +
                    "]", function (newValues, oldValues) {
                        if (initCycle) {
                            initCycle = false;
                        }
                        else {
                            if (_this.gridOptions.currentPage !== 0) {
                                TrNgGrid.debugMode && _this.log("Changes detected in parameters in server-side mode. Requesting a page index reset...");
                                pageIndexResetRequired = true;
                            }
                            TrNgGrid.debugMode && _this.log("Changes detected in parameters in server-side mode. Scheduling data retrieval...");
                            _this.scheduleServerSideModeDataRetrieval();
                        }
                    });
                this.scheduleServerSideModeDataRetrieval();
                this.speedUpServerSideModeDataRetrieval();
            }
            else {
                this.speedUpServerSideModeDataRetrieval = function ($event) { };
            }
            gridScope.speedUpAsyncDataRetrieval = function ($event) { return _this.speedUpServerSideModeDataRetrieval($event); };
        };
        GridController.prototype.setupDataSelectionTriggers = function (gridScope) {
            var _this = this;
            gridScope.$watch("gridOptions.selectionMode", function (newValue, oldValue) {
                if (newValue !== oldValue) {
                    switch (newValue) {
                        case SelectionMode[SelectionMode.None]:
                            _this.gridOptions.selectedItems.splice(0);
                            break;
                        case SelectionMode[SelectionMode.SingleRow]:
                            if (_this.gridOptions.selectedItems.length > 1) {
                                _this.gridOptions.selectedItems.splice(1);
                            }
                            break;
                    }
                }
            });
        };
        GridController.prototype.setColumnOptions = function (columnIndex, columnOptions) {
            var originalOptions = this.gridOptions.gridColumnDefs[columnIndex];
            if (!originalOptions) {
                throw "Invalid grid column options found for column index " + columnIndex + ". Please report this error.";
            }
            columnOptions = angular.extend(columnOptions, originalOptions);
            this.gridOptions.gridColumnDefs[columnIndex] = columnOptions;
        };
        GridController.prototype.toggleSorting = function (propertyName) {
            if (this.gridOptions.orderBy != propertyName) {
                this.gridOptions.orderBy = propertyName;
            }
            else {
                this.gridOptions.orderByReverse = !this.gridOptions.orderByReverse;
            }
            this.speedUpServerSideModeDataRetrieval();
        };
        GridController.prototype.toggleItemSelection = function (filteredItems, item, $event) {
            if (this.gridOptions.selectionMode === SelectionMode[SelectionMode.None])
                return;
            switch (this.gridOptions.selectionMode) {
                case SelectionMode[SelectionMode.MultiRowWithKeyModifiers]:
                    if (!$event["ctrlKey"] && !$event["shiftKey"] && !$event["metaKey"]) {
                        var itemIndex = this.gridOptions.selectedItems.indexOf(item);
                        this.gridOptions.selectedItems.splice(0);
                        if (itemIndex < 0) {
                            this.gridOptions.selectedItems.push(item);
                        }
                    }
                    else {
                        if ($event["ctrlKey"] || $event["metaKey"]) {
                            var itemIndex = this.gridOptions.selectedItems.indexOf(item);
                            if (itemIndex >= 0) {
                                this.gridOptions.selectedItems.splice(itemIndex, 1);
                            }
                            else {
                                this.gridOptions.selectedItems.push(item);
                            }
                        }
                        else if ($event["shiftKey"]) {
                            if (document["selection"] && document["selection"].empty) {
                                document["selection"].empty();
                            }
                            else if (window.getSelection) {
                                var sel = window.getSelection();
                                sel.removeAllRanges();
                            }
                            var firstItemIndex;
                            var lastSelectedItem = this.gridOptions.selectedItems[this.gridOptions.selectedItems.length - 1];
                            for (firstItemIndex = 0; firstItemIndex < filteredItems.length && filteredItems[firstItemIndex].$$_gridItem !== lastSelectedItem; firstItemIndex++)
                                ;
                            if (firstItemIndex >= filteredItems.length) {
                                firstItemIndex = 0;
                            }
                            var lastItemIndex;
                            for (lastItemIndex = 0; lastItemIndex < filteredItems.length && filteredItems[lastItemIndex].$$_gridItem !== item; lastItemIndex++)
                                ;
                            if (lastItemIndex >= filteredItems.length) {
                                throw "Invalid selection on a key modifier selection mode";
                            }
                            if (lastItemIndex < firstItemIndex) {
                                var tempIndex = firstItemIndex;
                                firstItemIndex = lastItemIndex;
                                lastItemIndex = tempIndex;
                            }
                            for (var currentItemIndex = firstItemIndex; currentItemIndex <= lastItemIndex; currentItemIndex++) {
                                var currentItem = filteredItems[currentItemIndex].$$_gridItem;
                                if (this.gridOptions.selectedItems.indexOf(currentItem) < 0) {
                                    this.gridOptions.selectedItems.push(currentItem);
                                }
                            }
                        }
                    }
                    break;
                case SelectionMode[SelectionMode.SingleRow]:
                    var itemIndex = this.gridOptions.selectedItems.indexOf(item);
                    this.gridOptions.selectedItems.splice(0);
                    if (itemIndex < 0) {
                        this.gridOptions.selectedItems.push(item);
                    }
                    break;
                case SelectionMode[SelectionMode.MultiRow]:
                    var itemIndex = this.gridOptions.selectedItems.indexOf(item);
                    if (itemIndex >= 0) {
                        this.gridOptions.selectedItems.splice(itemIndex, 1);
                    }
                    else {
                        this.gridOptions.selectedItems.push(item);
                    }
                    break;
            }
        };
        GridController.prototype.discoverTemplates = function (gridElement) {
            this.templatedHeader = new TemplatedSection("thead", null, null, "th", cellHeaderDirectiveAttribute);
            this.templatedBody = new TemplatedSection("tbody", bodyDirectiveAttribute, null, "td", cellBodyDirectiveAttribute);
            this.templatedFooter = new TemplatedSection("tfoot", null, null, "td", cellFooterDirectiveAttribute);
            this.templatedHeader.discoverTemplates(gridElement);
            this.templatedFooter.discoverTemplates(gridElement);
            this.templatedBody.discoverTemplates(gridElement);
        };
        GridController.prototype.getSafeFieldName = function (fieldName) {
            return fieldName.replace(/[^a-zA-Z0-9]/g, "_");
        };
        GridController.prototype.configureTableStructure = function (parentScope, gridElement, oldScope) {
            var _this = this;
            try {
                gridElement.empty();
                if (oldScope) {
                    var scopeToBeDestroyed = oldScope;
                    this.$timeout(function () {
                        scopeToBeDestroyed.$destroy();
                    });
                    oldScope = null;
                }
                var scope = parentScope.$new();
                if (this.columnDefsItemsWatcherDeregistration) {
                    this.columnDefsItemsWatcherDeregistration();
                    this.columnDefsItemsWatcherDeregistration = null;
                }
                if (this.columnDefsFieldsWatcherDeregistration) {
                    this.columnDefsFieldsWatcherDeregistration();
                    this.columnDefsFieldsWatcherDeregistration = null;
                }
                this.columnDefsFieldsWatcherDeregistration = scope.$watch("gridOptions.fields", function (newValue, oldValue) {
                    if (!angular.equals(newValue, oldValue)) {
                        _this.configureTableStructure(parentScope, gridElement, scope);
                    }
                }, true);
                var templatedHeaderPartialGridColumnDefs = this.templatedHeader.extractPartialColumnDefinitions();
                var templatedBodyPartialGridColumnDefs = this.templatedBody.extractPartialColumnDefinitions();
                var templatedFooterPartialGridColumnDefs = this.templatedFooter.extractPartialColumnDefinitions();
                var finalPartialGridColumnDefs = [];
                var fieldsEnforced = this.gridOptions.fields;
                if (fieldsEnforced) {
                    angular.forEach(this.gridOptions.fields, function (fieldName) {
                        if (fieldName) {
                            finalPartialGridColumnDefs.push({
                                isStandardColumn: true,
                                fieldName: fieldName
                            });
                        }
                    });
                    finalPartialGridColumnDefs = combineGridCellInfos(finalPartialGridColumnDefs, templatedHeaderPartialGridColumnDefs, false, true);
                    finalPartialGridColumnDefs = combineGridCellInfos(finalPartialGridColumnDefs, templatedBodyPartialGridColumnDefs, false, true);
                }
                else {
                    if (templatedHeaderPartialGridColumnDefs.length > 0) {
                        finalPartialGridColumnDefs = combineGridCellInfos(templatedHeaderPartialGridColumnDefs, templatedBodyPartialGridColumnDefs, true, true);
                    }
                    else {
                        if (!this.gridOptions.items || this.gridOptions.items.length == 0) {
                            this.columnDefsItemsWatcherDeregistration = scope.$watch("gridOptions.items.length", function (newValue, oldValue) {
                                if (newValue) {
                                    _this.configureTableStructure(parentScope, gridElement, scope);
                                }
                            });
                            return;
                        }
                        for (var propName in this.gridOptions.items[0]) {
                            {
                                finalPartialGridColumnDefs.push({
                                    isStandardColumn: true,
                                    fieldName: propName
                                });
                            }
                        }
                        finalPartialGridColumnDefs = combineGridCellInfos(finalPartialGridColumnDefs, templatedBodyPartialGridColumnDefs, true, true);
                    }
                }
                if (templatedFooterPartialGridColumnDefs.length == 0) {
                    templatedFooterPartialGridColumnDefs.push({ isStandardColumn: true });
                }
                angular.forEach(finalPartialGridColumnDefs, function (columnDefs) {
                    if (columnDefs.fieldName) {
                        var fieldName = columnDefs.fieldName;
                        columnDefs.displayFieldName = _this.getSafeFieldName(fieldName);
                        var fieldExtractionExpression;
                        if (fieldName[0] === "[") {
                            fieldExtractionExpression = fieldName;
                        }
                        else {
                            fieldExtractionExpression = fieldName.replace(/^([^\.]+)/g, "\[\"$1\"]");
                        }
                        columnDefs.fieldExtractionExpression = fieldExtractionExpression;
                    }
                });
                this.gridOptions.gridColumnDefs = finalPartialGridColumnDefs;
                var headerElement = this.templatedHeader.configureSection(gridElement, finalPartialGridColumnDefs);
                var footerElement = this.templatedFooter.configureSection(gridElement, templatedFooterPartialGridColumnDefs);
                var bodyElement = this.templatedBody.configureSection(gridElement, finalPartialGridColumnDefs);
                var templatedBodyRowElement = this.templatedBody.getTemplatedRowElement(bodyElement);
                var templatedHeaderRowElement = this.templatedHeader.getTemplatedRowElement(headerElement);
                bodyElement.attr(bodyDirectiveAttribute, "");
                templatedBodyRowElement.attr("ng-click", "toggleItemSelection(gridItem, $event)");
                templatedBodyRowElement.attr("ng-repeat", "gridDisplayItem in filteredItems");
                templatedBodyRowElement.attr("ng-init", "gridItem=gridDisplayItem.$$_gridItem;" + templatedBodyRowElement.attr("ng-init"));
                var ngClassValue = templatedBodyRowElement.attr("ng-class");
                ngClassValue = (ngClassValue || "").replace(/^(\s*\{?)(.*?)(\}?\s*)$/, "{'" + TrNgGrid.rowSelectedCssClass + "':gridOptions.selectedItems.indexOf(gridItem) >= 0" + ", $2}");
                templatedBodyRowElement.attr("ng-class", ngClassValue);
                this.$compile(headerElement)(scope);
                this.$compile(footerElement)(scope);
                this.$compile(bodyElement)(scope);
            }
            catch (ex) {
                TrNgGrid.debugMode && this.log("Fixing table structure failed with error " + ex);
                throw ex;
            }
        };
        GridController.prototype.computeFormattedItems = function (scope) {
            var input = scope.gridOptions.items || [];
            TrNgGrid.debugMode && this.log("formatting items of length " + input.length);
            try {
                var formattedItems = scope.formattedItems = (scope.formattedItems || []);
                var gridColumnDefs = scope.gridOptions.gridColumnDefs;
                for (var inputIndex = 0; inputIndex < input.length; inputIndex++) {
                    var gridItem = input[inputIndex];
                    var outputItem;
                    var localEvalVars = { gridItem: gridItem };
                    while (formattedItems.length > input.length && (outputItem = formattedItems[inputIndex]).$$_gridItem !== gridItem) {
                        formattedItems.splice(inputIndex, 1);
                    }
                    if (inputIndex < formattedItems.length) {
                        outputItem = formattedItems[inputIndex];
                        if (outputItem.$$_gridItem !== gridItem) {
                            outputItem = { $$_gridItem: gridItem };
                            formattedItems[inputIndex] = outputItem;
                        }
                    }
                    else {
                        outputItem = { $$_gridItem: gridItem };
                        formattedItems.push(outputItem);
                    }
                    for (var gridColumnDefIndex = 0; gridColumnDefIndex < gridColumnDefs.length; gridColumnDefIndex++) {
                        var fieldName;
                        try {
                            var gridColumnDef = gridColumnDefs[gridColumnDefIndex];
                            if (gridColumnDef.displayFieldName && gridColumnDef.fieldExtractionExpression) {
                                var displayFormat = gridColumnDef.displayFormat;
                                if (displayFormat) {
                                    if (displayFormat[0] !== "." && displayFormat[0] !== "|" && displayFormat[0] !== "[") {
                                        displayFormat = " | " + displayFormat;
                                    }
                                }
                                outputItem[gridColumnDef.displayFieldName] = scope.$eval("gridItem" + gridColumnDef.fieldExtractionExpression + (displayFormat || ""), localEvalVars);
                            }
                        }
                        catch (ex) {
                            TrNgGrid.debugMode && this.log("Field evaluation failed for <" + (fieldName || "unknown") + "> with error " + ex);
                        }
                    }
                }
                if (formattedItems.length > input.length) {
                    formattedItems.splice(input.length, formattedItems.length - input.length);
                }
                this.scheduleDataFiltering();
            }
            catch (ex) {
                TrNgGrid.debugMode && this.log("Failed to format items " + ex);
                throw ex;
            }
        };
        GridController.prototype.extractDataItems = function (formattedItems) {
            var dataItems;
            if (formattedItems) {
                dataItems = new Array(formattedItems.length);
                for (var index = 0; index < formattedItems.length; index++) {
                    dataItems[index] = formattedItems[index].$$_gridItem;
                }
            }
            else {
                dataItems = [];
            }
            return dataItems;
        };
        GridController.prototype.computeFilteredItems = function (scope) {
            try {
                if (this.isInServerSideMode) {
                    scope.filteredItems = scope.formattedItems;
                }
                else {
                    scope.filterByDisplayFields = {};
                    if (scope.gridOptions.filterByFields) {
                        for (var fieldName in scope.gridOptions.filterByFields) {
                            scope.filterByDisplayFields[this.getSafeFieldName(fieldName)] = scope.gridOptions.filterByFields[fieldName];
                        }
                    }
                    TrNgGrid.debugMode && this.log("filtering items of length " + (scope.formattedItems ? scope.formattedItems.length : 0));
                    scope.filteredItems = scope.$eval("formattedItems | filter:gridOptions.filterBy | filter:filterByDisplayFields | " + TrNgGrid.sortFilter + ":gridOptions");
                    if (scope.gridOptions.filteredItems) {
                        scope.gridOptions.filteredItems = this.extractDataItems(scope.filteredItems);
                    }
                    scope.filteredItems = scope.$eval("filteredItems | " + TrNgGrid.dataPagingFilter + ":gridOptions");
                }
                if (scope.gridOptions.filteredItemsPage) {
                    scope.gridOptions.filteredItemsPage = this.extractDataItems(scope.filteredItems);
                }
            }
            catch (ex) {
                TrNgGrid.debugMode && this.log("Failed to filter items " + ex);
                throw ex;
            }
        };
        GridController.prototype.linkAttrs = function (tAttrs, localStorage) {
            var propSetter = function (propName, propValue) {
                if (typeof (propValue) === "undefined")
                    return;
                switch (propValue) {
                    case "true":
                        propValue = true;
                        break;
                    case "false":
                        propValue = false;
                        break;
                }
                localStorage[propName] = propValue;
            };
            for (var propName in localStorage) {
                propSetter(propName, tAttrs[propName]);
                (function (propName) {
                    tAttrs.$observe(propName, function (value) { return propSetter(propName, value); });
                })(propName);
            }
        };
        GridController.prototype.log = function (message) {
            console.log(tableDirective + "(" + new Date().getTime() + "): " + message);
        };
        return GridController;
    })();
    angular.module("trNgGrid", [])
        .directive(tableDirective, [
        function () {
            return {
                restrict: 'A',
                scope: {
                    items: '=',
                    selectedItems: '=?',
                    filteredItems: '=?',
                    filteredItemsPage: '=?',
                    filterBy: '=?',
                    filterByFields: '=?',
                    orderBy: '=?',
                    orderByReverse: '=?',
                    pageItems: '=?',
                    currentPage: '=?',
                    totalItems: '=?',
                    enableFiltering: '=?',
                    enableSorting: '=?',
                    selectionMode: '@',
                    locale: '@',
                    onDataRequired: '&',
                    onDataRequiredDelay: '=?',
                    fields: '=?'
                },
                controller: ["$compile", "$parse", "$timeout", "$templateCache", "$interpolate", GridController],
                compile: function (templateElement, tAttrs) {
                    angular.forEach(templateElement.children(), function (childElement) {
                        childElement = angular.element(childElement);
                        childElement.attr("ng-non-bindable", "");
                    });
                    return {
                        pre: function (isolatedScope, instanceElement, tAttrs, controller, transcludeFn) {
                            controller.discoverTemplates(instanceElement);
                        },
                        post: function (isolatedScope, instanceElement, tAttrs, controller, transcludeFn) {
                            instanceElement.addClass(TrNgGrid.tableCssClass);
                            var gridScope = isolatedScope.$parent.$new();
                            controller.setupGrid(gridScope, isolatedScope, !!tAttrs.onDataRequired);
                            controller.configureTableStructure(gridScope, instanceElement);
                            isolatedScope.$on("$destroy", function () {
                                gridScope.$destroy();
                                TrNgGrid.debugMode && controller.log("grid scope destroyed");
                            });
                        }
                    };
                }
            };
        }])
        .directive(cellHeaderDirective, [
        function () {
            var setupColumnTitle = function (scope) {
                if (scope.columnOptions.displayName) {
                    scope.columnTitle = scope.columnOptions.displayName;
                }
                else if (scope.columnOptions.fieldName) {
                    var rawTitle = scope.columnOptions.fieldName.replace(/^([^\a-zA-Z]*)([\a-zA-Z0-9]*)(.*)/g, "$2");
                    var splitTitleName = rawTitle.split(/(?=[A-Z])/);
                    if (splitTitleName.length && splitTitleName[0].length) {
                        splitTitleName[0] = splitTitleName[0][0].toLocaleUpperCase() + splitTitleName[0].substr(1);
                    }
                    scope.columnTitle = splitTitleName.join(" ");
                }
                else {
                    scope.columnTitle = "";
                }
            };
            return {
                restrict: 'A',
                require: '^' + tableDirective,
                scope: true,
                compile: function (templateElement, tAttrs) {
                    var isCustomized = tAttrs['isCustomized'] == 'true';
                    wrapTemplatedCell(templateElement, tAttrs, isCustomized, cellHeaderTemplateDirectiveAttribute);
                    return {
                        pre: function (scope, instanceElement, tAttrs, controller, $transclude) {
                            var columnIndex = parseInt(tAttrs[cellHeaderDirective]);
                            var columnOptions = angular.extend(scope.gridOptions.gridColumnDefs[columnIndex], TrNgGrid.defaultColumnOptionsTemplate, TrNgGrid.defaultColumnOptions);
                            controller.linkAttrs(tAttrs, columnOptions);
                            scope.columnOptions = columnOptions;
                            scope.isCustomized = isCustomized;
                            scope.toggleSorting = function (propertyName) {
                                controller.toggleSorting(propertyName);
                            };
                            scope.$watch("columnOptions.displayName", function () {
                                setupColumnTitle(scope);
                            });
                            var isWatchingColumnFilter = false;
                            scope.$watch("gridOptions.filterByFields['" + columnOptions.fieldName + "']", function (newFilterValue, oldFilterValue) {
                                if (columnOptions.filter !== newFilterValue) {
                                    columnOptions.filter = newFilterValue;
                                }
                                if (!isWatchingColumnFilter) {
                                    scope.$watch("columnOptions.filter", function (newFilterValue, oldFilterValue) {
                                        if (scope.gridOptions.filterByFields[columnOptions.fieldName] !== newFilterValue) {
                                            if (!newFilterValue) {
                                                delete (scope.gridOptions.filterByFields[columnOptions.fieldName]);
                                            }
                                            else {
                                                scope.gridOptions.filterByFields[columnOptions.fieldName] = newFilterValue;
                                            }
                                            scope.gridOptions.filterByFields = angular.extend({}, scope.gridOptions.filterByFields);
                                        }
                                    });
                                    isWatchingColumnFilter = true;
                                }
                            });
                        }
                    };
                }
            };
        }
        ])
        .directive(cellHeaderTemplateDirective, [
        function () {
            return {
                restrict: 'A',
                templateUrl: TrNgGrid.cellHeaderTemplateId,
                transclude: true,
                replace: true,
            };
        }
        ])
        .directive(bodyDirective, [
        function () {
            return {
                restrict: 'A',
                require: '^' + tableDirective,
                scope: true,
                compile: function (templateElement, tAttrs) {
                    return {
                        pre: function (scope, compiledInstanceElement, tAttrs, controller) {
                            scope.toggleItemSelection = function (item, $event) {
                                controller.toggleItemSelection(scope.filteredItems, item, $event);
                            };
                        }
                    };
                }
            };
        }
        ])
        .directive(cellBodyDirective, [
        function () {
            return {
                restrict: 'A',
                require: '^' + tableDirective,
                scope: true,
                compile: function (templateElement, tAttrs) {
                    var isCustomized = tAttrs['isCustomized'] == 'true';
                    wrapTemplatedCell(templateElement, tAttrs, isCustomized, cellBodyTemplateDirectiveAttribute);
                    return {
                        pre: function (scope, instanceElement, tAttrs, controller, $transclude) {
                            scope.columnOptions = scope.gridOptions.gridColumnDefs[parseInt(tAttrs[cellBodyDirective])];
                            scope.gridItem = scope.gridDisplayItem.$$_gridItem;
                            scope.isCustomized = isCustomized;
                        }
                    };
                }
            };
        }
        ])
        .directive(cellBodyTemplateDirective, [
        function () {
            return {
                restrict: 'A',
                templateUrl: TrNgGrid.cellBodyTemplateId,
                transclude: true,
                replace: true
            };
        }
        ])
        .directive(cellFooterDirective, [
        function () {
            return {
                restrict: 'A',
                require: '^' + tableDirective,
                scope: true,
                compile: function (templateElement, tAttrs) {
                    var isCustomized = tAttrs['isCustomized'] == 'true';
                    wrapTemplatedCell(templateElement, tAttrs, isCustomized, cellFooterTemplateDirectiveAttribute);
                    return {
                        pre: function (scope, instanceElement, tAttrs, controller, $transclude) {
                            scope.isCustomized = isCustomized;
                            instanceElement.attr("colspan", scope.gridOptions.gridColumnDefs.length);
                        }
                    };
                }
            };
        }
        ])
        .directive(cellFooterTemplateDirective, [
        function () {
            return {
                restrict: 'A',
                templateUrl: TrNgGrid.cellFooterTemplateId,
                transclude: true,
                replace: true
            };
        }
        ])
        .directive(columnSortDirective, [
        function () {
            return {
                restrict: 'A',
                replace: true,
                templateUrl: TrNgGrid.columnSortTemplateId
            };
        }
        ])
        .directive(columnFilterDirective, [
        function () {
            return {
                restrict: 'A',
                replace: true,
                templateUrl: TrNgGrid.columnFilterTemplateId
            };
        }
        ])
        .directive(globalFilterDirective, [
        function () {
            return {
                restrict: 'A',
                scope: false,
                templateUrl: TrNgGrid.footerGlobalFilterTemplateId,
            };
        }
        ])
        .directive(pagerDirective, [
        function () {
            var setupScope = function (scope, controller) {
                scope.totalItemsCount = (typeof (scope.gridOptions.totalItems) != "undefined" && scope.gridOptions.totalItems != null)
                    ? scope.gridOptions.totalItems
                    : (scope.gridOptions.items ? scope.gridOptions.items.length : 0);
                scope.isPaged = (!!scope.gridOptions.pageItems) && (scope.gridOptions.pageItems < scope.totalItemsCount);
                scope.extendedControlsActive = false;
                scope.lastPageIndex = (!scope.totalItemsCount || !scope.isPaged)
                    ? 0
                    : (Math.floor(scope.totalItemsCount / scope.gridOptions.pageItems) + ((scope.totalItemsCount % scope.gridOptions.pageItems) ? 0 : -1));
                if (scope.gridOptions.currentPage > scope.lastPageIndex) {
                    TrNgGrid.debugMode && controller.log("The current page index falls outside of the range of items. Either the attached parameter has a wrong value or the total items count is not properly set in server side mode.");
                    scope.gridOptions.currentPage = scope.lastPageIndex;
                }
                scope.startItemIndex = scope.isPaged ? (scope.gridOptions.pageItems * scope.gridOptions.currentPage) : 0;
                scope.endItemIndex = scope.isPaged ? (scope.startItemIndex + scope.gridOptions.pageItems - 1) : scope.totalItemsCount - 1;
                if (scope.endItemIndex >= scope.totalItemsCount) {
                    scope.endItemIndex = scope.totalItemsCount - 1;
                }
                if (scope.endItemIndex < scope.startItemIndex) {
                    scope.endItemIndex = scope.startItemIndex;
                }
                scope.pageCanGoBack = scope.isPaged && scope.gridOptions.currentPage > 0;
                scope.pageCanGoForward = scope.isPaged && scope.gridOptions.currentPage < scope.lastPageIndex;
                scope.pageIndexes = scope.pageIndexes || [];
                scope.pageIndexes.splice(0);
                if (scope.isPaged) {
                    if (scope.lastPageIndex + 1 > TrNgGrid.defaultPagerMinifiedPageCountThreshold) {
                        scope.extendedControlsActive = true;
                        var pageIndexHalfRange = Math.floor(TrNgGrid.defaultPagerMinifiedPageCountThreshold / 2);
                        var lowPageIndex = scope.gridOptions.currentPage - pageIndexHalfRange;
                        var highPageIndex = scope.gridOptions.currentPage + pageIndexHalfRange;
                        if (lowPageIndex < 0) {
                            highPageIndex += -lowPageIndex;
                            lowPageIndex = 0;
                        }
                        else if (highPageIndex > scope.lastPageIndex) {
                            lowPageIndex -= highPageIndex - scope.lastPageIndex;
                            highPageIndex = scope.lastPageIndex;
                        }
                        if (lowPageIndex > 0) {
                            scope.pageIndexes.push(null);
                            lowPageIndex++;
                        }
                        var highPageEllipsed = false;
                        if (highPageIndex < scope.lastPageIndex) {
                            highPageEllipsed = true;
                            highPageIndex--;
                        }
                        for (var pageIndex = lowPageIndex; pageIndex <= highPageIndex; pageIndex++) {
                            scope.pageIndexes.push(pageIndex);
                        }
                        if (highPageEllipsed) {
                            scope.pageIndexes.push(null);
                        }
                    }
                    else {
                        scope.extendedControlsActive = false;
                        for (var pageIndex = 0; pageIndex <= scope.lastPageIndex; pageIndex++) {
                            scope.pageIndexes.push(pageIndex);
                        }
                    }
                }
                scope.pageSelectionActive = scope.pageIndexes.length > 1;
                scope.navigateToPage = function (pageIndex) {
                    scope.gridOptions.currentPage = pageIndex;
                    scope.speedUpAsyncDataRetrieval();
                };
                scope.switchPageSelection = function ($event, pageSelectionActive) {
                    scope.pageSelectionActive = pageSelectionActive;
                    if ($event) {
                        $event.preventDefault();
                        $event.stopPropagation();
                    }
                };
            };
            return {
                restrict: 'A',
                scope: true,
                require: '^' + tableDirective,
                templateUrl: TrNgGrid.footerPagerTemplateId,
                replace: true,
                compile: function (templateElement, tAttrs) {
                    return {
                        pre: function (scope, compiledInstanceElement, tAttrs, controller) {
                            setupScope(scope, controller);
                        },
                        post: function (scope, instanceElement, tAttrs, controller) {
                            scope.$watchCollection("[gridOptions.currentPage, gridOptions.items.length, gridOptions.totalItems, gridOptions.pageItems]", function (newValues, oldValues) {
                                setupScope(scope, controller);
                            });
                        }
                    };
                }
            };
        }
        ])
        .filter(TrNgGrid.sortFilter, ["$filter", "$parse", function ($filter, $parse) {
            return function (input, gridOptions) {
                if (!gridOptions.orderBy || !gridOptions.gridColumnDefs) {
                    return input;
                }
                var columnOptions = null;
                for (var columnOptionsIndex = 0; (columnOptionsIndex < gridOptions.gridColumnDefs.length) && ((columnOptions = gridOptions.gridColumnDefs[columnOptionsIndex]).fieldName !== gridOptions.orderBy) ; columnOptions = null, columnOptionsIndex++)
                    ;
                if (!columnOptions) {
                    return input;
                }
                var sortedInput = $filter("orderBy")(input, function (item) {
                    var fieldValue = undefined;
                    if (columnOptions.fieldExtractionExpression) {
                        try {
                            fieldValue = $parse("item.$$_gridItem" + columnOptions.fieldExtractionExpression)({ item: item });
                        }
                        catch (ex) {
                        }
                    }
                    if (fieldValue === undefined) {
                        try {
                            fieldValue = $parse("item[\"" + columnOptions.displayFieldName + "\"]")({ item: item });
                        }
                        catch (ex) {
                        }
                    }
                    return fieldValue;
                }, gridOptions.orderByReverse);
                return sortedInput;
            };
        }])
        .filter(TrNgGrid.dataPagingFilter, function () {
            return function (input, gridOptions) {
                if (input)
                    gridOptions.totalItems = input.length;
                if (!gridOptions.pageItems || !input || input.length == 0)
                    return input;
                if (!gridOptions.currentPage) {
                    gridOptions.currentPage = 0;
                }
                var startIndex = gridOptions.currentPage * gridOptions.pageItems;
                if (startIndex >= input.length) {
                    gridOptions.currentPage = 0;
                    startIndex = 0;
                }
                var endIndex = gridOptions.currentPage * gridOptions.pageItems + gridOptions.pageItems;
                return input.slice(startIndex, endIndex);
            };
        })
        .filter(TrNgGrid.translateFilter, ["$filter", "$injector", function ($filter, $injector) {
            return function (input, languageId) {
                var translatedText = null;
                if (!languageId) {
                    throw "Language identifier is not set";
                }
                if (input instanceof Date) {
                    var dateFormat = $filter(TrNgGrid.translateFilter)(TrNgGrid.translationDateFormat, languageId);
                    if (dateFormat && dateFormat !== TrNgGrid.translationDateFormat) {
                        translatedText = $filter("date")(input, dateFormat);
                        return translatedText;
                    }
                    return input;
                }
                var languageIdParts = languageId.split(/[-_]/);
                for (var languageIdPartIndex = languageIdParts.length; (languageIdPartIndex > 0) && (!translatedText) ; languageIdPartIndex--) {
                    var subLanguageId = languageIdParts.slice(0, languageIdPartIndex).join("-");
                    var langTranslations = TrNgGrid.translations[subLanguageId];
                    if (langTranslations) {
                        translatedText = langTranslations[input];
                    }
                }
                if (!translatedText && $injector.has("translateFilter")) {
                    try {
                        translatedText = $filter("translate")(input);
                    }
                    catch (ex) {
                    }
                }
                if (!translatedText) {
                    translatedText = input;
                }
                return translatedText;
            };
        }])
        .run(function () {
            TrNgGrid.tableCssClass = "tr-ng-grid table table-bordered table-hover";
            TrNgGrid.cellCssClass = "tr-ng-cell";
            TrNgGrid.headerCellCssClass = "tr-ng-column-header " + TrNgGrid.cellCssClass;
            TrNgGrid.bodyCellCssClass = TrNgGrid.cellCssClass;
            TrNgGrid.columnTitleCssClass = "tr-ng-title";
            TrNgGrid.columnSortCssClass = "tr-ng-sort";
            TrNgGrid.columnFilterCssClass = "tr-ng-column-filter";
            TrNgGrid.columnFilterInputWrapperCssClass = "";
            TrNgGrid.columnSortActiveCssClass = "tr-ng-sort-active text-info";
            TrNgGrid.columnSortInactiveCssClass = "tr-ng-sort-inactive text-muted glyphicon glyphicon-chevron-down";
            TrNgGrid.columnSortReverseOrderCssClass = "tr-ng-sort-order-reverse glyphicon glyphicon-chevron-down";
            TrNgGrid.columnSortNormalOrderCssClass = "tr-ng-sort-order-normal glyphicon glyphicon-chevron-up";
            TrNgGrid.rowSelectedCssClass = "active";
            TrNgGrid.footerCssClass = "tr-ng-grid-footer form-inline";
        })
        .run(function () {
            TrNgGrid.defaultColumnOptions.displayAlign = 'left';
            TrNgGrid.defaultPagerMinifiedPageCountThreshold = 3;
        });
    function addTemplate($templateCache, $interpolate, id, content) {
        var start = $interpolate.startSymbol(), end = $interpolate.endSymbol();
        if (!$templateCache.get(id)) {
            if (start !== '{{') {
                content = content.replace(/\{\{/g, start + ' ');
            }
            if (end !== '}}') {
                content = content.replace(/\}\}/g, ' ' + end);
            }
            $templateCache.put(id, content);
        }
    }
    ;
    function configureTemplates($templateCache, $interpolate) {
        addTemplate($templateCache, $interpolate, TrNgGrid.cellHeaderTemplateId, '<div class="' + TrNgGrid.headerCellCssClass + '" ng-switch="isCustomized">'
            + '  <div ng-switch-when="true">'
            + '    <div ng-transclude=""></div>'
            + '  </div>'
            + '  <div ng-switch-default>'
            + '    <div class="' + TrNgGrid.columnTitleCssClass + '">'
            + '      <div ng-bind-html="columnTitle |' + TrNgGrid.translateFilter + ':gridOptions.locale"></div>'
            + '       <div ' + TrNgGrid.columnSortDirectiveAttribute + '=""></div>'
            + '    </div>'
            + '    <div ' + TrNgGrid.columnFilterDirectiveAttribute + '=""></div>'
            + '  </div>'
            + '</div>');
        addTemplate($templateCache, $interpolate, TrNgGrid.cellBodyTemplateId, '<div ng-attr-class="' + TrNgGrid.bodyCellCssClass + ' text-{{columnOptions.displayAlign}}" ng-switch="isCustomized">'
            + '  <div ng-switch-when="true" class="tooltip-grid-notes" ng-mouseover="showTooltip(gridDisplayItem[columnOptions.displayFieldName], $event)" ng-mouseout="showTooltip(gridDisplayItem[columnOptions.displayFieldName], $event)">'
            + '    <div ng-transclude=""></div>'
            + '  </div>'
            + '  <div ng-switch-default class="tooltip-grid-notes" ng-mouseover="showTooltip(gridDisplayItem[columnOptions.displayFieldName], $event)" ng-mouseout="showTooltip(gridDisplayItem[columnOptions.displayFieldName], $event)">'
            + '     {{gridDisplayItem[columnOptions.displayFieldName]}} '
            + '   </div> '
            + '  <div class="grid_tooltips"> '
            + '     {{gridDisplayItem[columnOptions.displayFieldName]}} '
            + '  </div>');
        addTemplate($templateCache, $interpolate, TrNgGrid.columnFilterTemplateId, '<div ng-show="(gridOptions.enableFiltering&&columnOptions.enableFiltering!==false)||columnOptions.enableFiltering" class="' + TrNgGrid.columnFilterCssClass + '">'
            + ' <div class="' + TrNgGrid.columnFilterInputWrapperCssClass + '">'
            + '   <input class="form-control input-sm" type="text" ng-model="columnOptions.filter" ng-keypress="speedUpAsyncDataRetrieval($event)"></input>'
            + ' </div>'
            + '</div>');
        addTemplate($templateCache, $interpolate, TrNgGrid.columnSortTemplateId, '<div ng-attr-title="{{\'Sort\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}"'
            + ' ng-show="(gridOptions.enableSorting&&columnOptions.enableSorting!==false)||columnOptions.enableSorting"'
            + ' ng-click="toggleSorting(columnOptions.fieldName)"'
            + ' class="' + TrNgGrid.columnSortCssClass + '" > '
            + '  <div ng-class="{\''
            + TrNgGrid.columnSortActiveCssClass + '\':gridOptions.orderBy==columnOptions.fieldName,\''
            + TrNgGrid.columnSortInactiveCssClass + '\':gridOptions.orderBy!=columnOptions.fieldName,\''
            + TrNgGrid.columnSortNormalOrderCssClass + '\':gridOptions.orderBy==columnOptions.fieldName&&!gridOptions.orderByReverse,\''
            + TrNgGrid.columnSortReverseOrderCssClass + '\':gridOptions.orderBy==columnOptions.fieldName&&gridOptions.orderByReverse}" >'
            + '  </div>'
            + '</div>');
        addTemplate($templateCache, $interpolate, TrNgGrid.cellFooterTemplateId, '<div class="' + TrNgGrid.footerCssClass + '" ng-switch="isCustomized">'
            + '  <div ng-switch-when="true">'
            + '    <div ng-transclude=""></div>'
            + '  </div>'
            + '  <div ng-switch-default>'
            + '    <span ' + TrNgGrid.globalFilterDirectiveAttribute + '=""></span>'
            + '    <span ' + TrNgGrid.pagerDirectiveAttribute + '=""></span>'
            + '  </div>'
            + '</div>');
        addTemplate($templateCache, $interpolate, TrNgGrid.footerGlobalFilterTemplateId, '<span ng-show="gridOptions.enableFiltering" class="pull-left form-group">'
            + '  <input class="form-control" type="text" ng-model="gridOptions.filterBy" ng-keypress="speedUpAsyncDataRetrieval($event)" ng-attr-placeholder="{{\'Search\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}"></input>'
            + '</span>');
        addTemplate($templateCache, $interpolate, TrNgGrid.footerPagerTemplateId, '<span class="pull-right form-group">'
            + ' <ul class="pagination">'
            + '   <li ng-class="{disabled:!pageCanGoBack}" ng-if="extendedControlsActive">'
            + '     <a href="" ng-click="pageCanGoBack&&navigateToPage(0)" ng-attr-title="{{\'First Page\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}">'
            + '         <span>&laquo;</span>'
            + '     </a>'
            + '   </li>'
            + '   <li ng-class="{disabled:!pageCanGoBack}" ng-if="extendedControlsActive">'
            + '     <a href="" ng-click="pageCanGoBack&&navigateToPage(gridOptions.currentPage - 1)" ng-attr-title="{{\'Previous Page\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}">'
            + '         <span>&lsaquo;</span>'
            + '     </a>'
            + '   </li>'
            + '   <li ng-if="pageSelectionActive" ng-repeat="pageIndex in pageIndexes track by $index" ng-class="{disabled:pageIndex===null, active:pageIndex===gridOptions.currentPage}">'
            + '      <span ng-if="pageIndex===null">...</span>'
            + '      <a href="" ng-click="navigateToPage(pageIndex)" ng-if="pageIndex!==null" ng-attr-title="{{\'Page\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}">{{pageIndex+1}}</a>'
            + '   </li>'
            + '   <li ng-class="{disabled:!pageCanGoForward}" ng-if="extendedControlsActive">'
            + '     <a href="" ng-click="pageCanGoForward&&navigateToPage(gridOptions.currentPage + 1)" ng-attr-title="{{\'Next Page\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}">'
            + '         <span>&rsaquo;</span>'
            + '     </a>'
            + '   </li>'
            + '   <li ng-class="{disabled:!pageCanGoForward}" ng-if="extendedControlsActive">'
            + '     <a href="" ng-click="pageCanGoForward&&navigateToPage(lastPageIndex)" ng-attr-title="{{\'Last Page\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}">'
            + '         <span>&raquo;</span>'
            + '     </a>'
            + '   </li>'
            + '   <li class="disabled" style="white-space: nowrap;">'
            + '     <span ng-hide="totalItemsCount">{{\'No items to display\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}</span>'
            + '     <span ng-show="totalItemsCount">'
            + '       {{startItemIndex+1}} - {{endItemIndex+1}} {{\'displayed\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}'
            + '       <span>, {{totalItemsCount}} {{\'in total\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}</span>'
            + '     </span > '
            + '   </li>'
            + ' </ul>'
            + '</span>');
    }
    ;
})(TrNgGrid || (TrNgGrid = {}));
